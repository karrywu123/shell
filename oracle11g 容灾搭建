实验环境
Red Hat Enterprise Linux Server release 6.8 (Santiago) 内存设为4G以上 
ip 192.168.5.180  为主库
ip 192.168.5.181  为备库
对比彩票的数据库做的容灾
数据库主库的实例名为cpdb 唯一名为cpdb
数据库备库的实例名为cpdbpdg  唯一名为cpdbpdg
基础配置，配置两边的oracle net，保证两边能互通（需要使用静态注册）
###########################################
主库上的listener配置
# listener.ora Network Configuration File: /home/u01/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora
# Generated by Oracle configuration tools.
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))
    )
  )

SID_LIST_LISTENER=

  (SID_LIST =

     (SID_DESC =

      (GLOBAL_DBNAME = cpdb)

      (ORACLE_HOME = /home/u01/app/oracle/product/11.2.0/dbhome_1)

      (SID_NAME = cpdb)

    )

  )

ADR_BASE_LISTENER = /home/u01/app/oracle

从库上的listener配置
# listener.ora Network Configuration File: /home/u01/app/oracle/product/11.2.0/dbhome_1/network/admin/listener.ora
# Generated by Oracle configuration tools.
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))
    )
  )

SID_LIST_LISTENER=

  (SID_LIST =

     (SID_DESC =

      (GLOBAL_DBNAME = cpdbpdg)

      (ORACLE_HOME = /home/u01/app/oracle/product/11.2.0/dbhome_1)

      (SID_NAME = cpdbpdg)

    )

  )

ADR_BASE_LISTENER = /home/u01/app/oracle

######################################################################
两边使用相同的tnsnames.ora
# tnsnames.ora Network Configuration File: /home/u01/app/oracle/product/11.2.0/dbhome_1/network/admin/tnsnames.ora
# Generated by Oracle configuration tools.

CPDB =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.5.180)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = cpdb)
    )
  )

CPDBPDG =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.5.181)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = cpdbpdg)
    )
  )
###################################################################################
现在是主库上面做容灾操作
在主库执行的操作：
 1.主库要运行在归档模式
 archive log list
 shutdown immediate
 startup mount
 alter database archivelog;
 alter database open;
 
 archive log list
 
 2.主库要打开force logging
 select force_logging from v$database;
 NO/YES
 alter database force logging
 3.创建备库日志文件路径
 
查看数据库的日志组个数与大小，因为我们创建 standby 日志组的个数是原日志
组个数+1 再与 thread 的积((2+1)*3)，size 不能小于原日志文件的大小。

SQL>  select group#,thread#,bytes/1024/1024 M ,STATUS from v$log;
select group#,thread#,sequence#,archived,status,bytes/1024/1024 M from v$standby_log;;-查询standby日志

    GROUP#    THREAD#          M STATUS
---------- ---------- ---------- ----------------
         1          1         50 INACTIVE
         2          1         50 CURRENT
         3          1         50 INACTIVE

SQL> select member from v$logfile;

MEMBER
--------------------------------------------------------------------------------
/home/u01/app/oracle/oradata/cpdb/redo03.log
/home/u01/app/oracle/oradata/cpdb/redo02.log
/home/u01/app/oracle/oradata/cpdb/redo01.log
 创建standby的远程传输日志
 alter database add standby logfile thread 1 group 4 ('/home/u01/app/oracle/oradata/cpdb/redo04.log') size 50M;
 alter database add standby logfile thread 1 group 5 ('/home/u01/app/oracle/oradata/cpdb/redo05.log') size 50M;
 alter database add standby logfile thread 1 group 6 ('/home/u01/app/oracle/oradata/cpdb/redo06.log') size 50M;
 alter database add logfile thread 1 group 7 ('/home/u01/app/oracle/oradata/ora11g/redo07.log') size 1000m;
  
 ALTER DATABASE ADD LOGFILE GROUP 
3修改主库的归档参数
 原来的主库归档为
 SQL> archive log list
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /home/u01/app/oracle/product/11.2.0/dbhome_1/dbs/arch
Oldest online log sequence     3
Next log sequence to archive   5
Current log sequence           5
现在的修改为:
设置主库和备库归档路径
mkdir /home/oracle/archivelog
mkdir /home/u01/app/oracle/fast_recovery_area
alter system set db_recovery_file_dest_size = 15000m;
alter system set db_recovery_file_dest='/home/u01/app/oracle/fast_recovery_area';
alter system set log_archive_dest_1='location=USE_DB_RECOVERY_FILE_DEST  VALID_FOR=(日志类型,数据库角色) db_unique_name=主库唯一名;
alter system set log_archive_dest_1='LOCATION=USE_DB_RECOVERY_FILE_DEST  VALID_FOR=(ALL_LOGFILES,ALL_ROLES)  DB_UNIQUE_NAME=cpdb';
主库启用远程归档参数

alter system set log_archive_dest_2='service=连接从库的服务命名 LGWR SYNC AFFIRM  valid_for=(日志类型,数据库角色) db_unique_name=备库库唯一名';
alter system set log_archive_dest_2='SERVICE=cpdbpdg LGWR SYNC AFFIRM  VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE)  DB_UNIQUE_NAME=cpdbpdg';

设置远程归档延时
NET_TIMEOUT=30
alter system set log_archive_dest_2='SERVICE=cpdbpdg LGWR SYNC AFFIRM NET_TIMEOUT=30 VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE)  DB_UNIQUE_NAME=cpdbpdg';

1.开启块检查

这样做的目标是尽早发现数据库中的坏块。这只会占用很少的性能开销，但却可以让 Oracle 尽早检测出由底层磁盘、存储系统、或 I/O 系统问题导致的坏块。

SQL> alter system set db_block_checking = true scope=both;



配置归档最大进程数
SQL> show parameter log_archive_max;

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
log_archive_max_processes            integer     4
SQL> alter system set log_archive_max_processes=30;
打开主库的dataguard开关
alter system set log_archive_config='dg_config=(主库的唯一名,从库的唯一名,从库的唯一名...)';
alter system set log_archive_config='dg_config=(cpdb,cpdbpdg)';
alter system set log_archive_dest_state_1='ENABLE';
alter system set log_archive_dest_state_2='ENABLE';
alter system set standby_file_management = 'AUTO';
alter system set fal_client='CPDB';
alter system set fal_server='CPDBPDG';
alter system set pga_aggregate_target=10G;
alter system set job_queue_processes= 1000;
#在文件系统文件上启用异步和直接I/O。
alter system set filesystemio_options = setall scope=spfile; 
#开启异步IO提高运行效率
alter system set disk_asynch_io = true scope=spfile;

alter system set utl_file_dir='/home/oracle/archivelog' scope=spfile;


alter system set sga_max_size=40G scope=spfile; 

alter system set sga_target=40G scope=spfile; 

SQL> commit;
 主库创建spfile文件
create pfile from spfile; 
重启数据库
得到的pfile文件为：
initcpdb.ora 

现在主库的配置基本配好
接下来将
主库为从库拷贝口令文件 和pfile  spfile 的文件
scp orapwcpdb oracle@192.168.5.181:/home/u01/app/oracle/product/11.2.0/dbhome_1/dbs/orapwcpdbpdg
scp initcpdb.ora oracle@192.168.5.181:/home/u01/app/oracle/product/11.2.0/dbhome_1/dbs/initcpdbpdg.ora

在备库的操作
修改nitcpdbpdg.ora 文件
cpdb.__db_cache_size=637534208
cpdb.__java_pool_size=16777216
cpdb.__large_pool_size=33554432
cpdb.__oracle_base='/home/u01/app/oracle'#ORACLE_BASE set from environment
cpdb.__pga_aggregate_target=671088640
cpdb.__sga_target=939524096
cpdb.__shared_io_pool_size=0
cpdb.__shared_pool_size=234881024
cpdb.__streams_pool_size=0
*.audit_file_dest='/home/u01/app/oracle/admin/cpdb/adump'
*.audit_trail='db'
*.compatible='11.2.0.4.0'
*.control_files='/home/u01/app/oracle/oradata/cpdb/control01.ctl','/home/u01/app/oracle/oradata/cpdb/control02.ctl'
*.db_block_size=8192
*.db_domain=''
*.db_name='cpdb'
*.db_unique_name='cpdbpdg'
*.db_recovery_file_dest_size=20971520
*.db_recovery_file_dest='/home/u01/app/oracle/fast_recovery_area'
*.diagnostic_dest='/home/u01/app/oracle'
*.dispatchers='(PROTOCOL=TCP) (SERVICE=cpdbXDB)'
*.fal_client='CPDBPDG'
*.fal_server='CPDB'
*.filesystemio_options='SETALL'
*.log_archive_config='dg_config=(cpdb,cpdbpdg)'
*.log_archive_dest_1='LOCATION=USE_DB_RECOVERY_FILE_DEST  VALID_FOR=(ALL_LOGFILES,ALL_ROLES)  DB_UNIQUE_NAME=cpdbpdg'
*.log_archive_dest_2='SERVICE=cpdbpdg LGWR SYNC AFFIRM VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE)  DB_UNIQUE_NAME=cpdb'
*.log_archive_dest_state_1='ENABLE'
*.log_archive_dest_state_2='ENABLE'
*.log_archive_max_processes=30
*.memory_target=1600126976
*.open_cursors=300
*.pga_aggregate_target=0
*.processes=150
*.remote_login_passwordfile='EXCLUSIVE'
*.standby_file_management='AUTO'
*.undo_tablespace='UNDOTBS1'
*.utl_file_dir='/home/oracle/archivelog'
为备库创建对应的文件夹
[oracle@localhost dbs]$ mkdir /home/oracle/archivelog
[oracle@localhost dbs]$ mkdir /home/u01/app/oracle/fast_recovery_area
[oracle@localhost dbs]$ mkdir -p /home/u01/app/oracle/admin/cpdb/adump
[oracle@localhost dbs]$ mkdir -p /home/u01/app/oracle/oradata/cpdb

修改从库环境变量，创建spfile，启动实例到nomount
export ORACLE_SID=cpdbpdg
 sqlplus / as sysdba
 create spfile from pfile;
 startup nomount

 在主库使用网络连接从库
 sqlplus sys/123456@cpdbpdg as sysdba
 在主库操作
 alter system set db_recovery_file_dest_size=3G scope=spfile;
在主库启动rman复制从库
 使用新创建的参数文件启动主库到open状态，启动从库到nomount状态（注意spfile的影响，可以mv掉对应的spfile）
 
 rman target sys/123456@cpdb auxiliary sys/123456@cpdbpdg  nocatalog
rman target  / auxiliary sys/123456@cpdbpdg nocatalog
接下来重启从库
SQL> shutdown immediate
ORA-01507: database not mounted


ORACLE instance shut down.
SQL>  startup nomount
ORACLE instance started.

Total System Global Area 1603411968 bytes
Fixed Size                  2253664 bytes
Variable Size            1459621024 bytes
Database Buffers          134217728 bytes
Redo Buffers                7319552 bytes
接下来 开始从主库rman复制
duplicate target database for standby from active database;



常见问题：
（1）如果使用的是非catalog，在rman 连接时，加上nocatalog关键字,否则可能会报TARGET> begin :fhdbi := dbms_rcvcat.getDbid; end;的错误
（2） 在执行duplicate的时候，如果源库和目标库目录相同，那么在duplicate 时，需要加上nofilenamecheck
duplicate target database for standby nofilenamecheck from active database;

1. 备库开启日志应用
 
开启备库日志应用
SQL> alter database recover managed standby database using current logfile disconnect from session;
Database altered.
验证备库接收日志是否应用

SQL> select SEQUENCE#,FIRST_TIME,NEXT_TIME ,APPLIED from v$archived_log order by 1;

 SEQUENCE# FIRST_TIM NEXT_TIME APPLIED
---------- --------- --------- ---------
        10 31-DEC-17 31-DEC-17 YES
        
  主库切换日志      
SQL> alter system switch logfile;

System altered.
SQL> /

System altered.
备库查看日志
SQL> select SEQUENCE#,FIRST_TIME,NEXT_TIME ,APPLIED from v$archived_log;

 SEQUENCE# FIRST_TIM NEXT_TIME APPLIED
---------- --------- --------- ---------
        10 31-DEC-17 31-DEC-17 YES
 
备库数据库开启read only
SQL> alter database open read only;
alter database open read only
*
ERROR at line 1:
ORA-10456: cannot open standby database; media recovery session may be in
progress

 关闭备库管理
 SQL> alter database recover managed standby database cancel;

Database altered.
主库切换日志

SQL> alter system switch logfile;

System altered.
备库接收但未应用

SQL> select SEQUENCE#,FIRST_TIME,NEXT_TIME ,APPLIED from v$archived_log order by 1;

 SEQUENCE# FIRST_TIM NEXT_TIME APPLIED
---------- --------- --------- ---------
         5 30-DEC-17 31-DEC-17 NO
         6 31-DEC-17 31-DEC-17 NO
         7 31-DEC-17 31-DEC-17 NO
         8 31-DEC-17 31-DEC-17 NO
         9 31-DEC-17 31-DEC-17 NO
        10 31-DEC-17 31-DEC-17 NO
        11 31-DEC-17 31-DEC-17 NO
        12 31-DEC-17 31-DEC-17 NO
        13 31-DEC-17 31-DEC-17 NO

9 rows selected.
备库开启只读模式
SQL> alter database open read only;

Database altered.
备库开启日志应用
SQL> alter database recover managed standby database using current logfile disconnect from session;

Database altered.
备库已经应用日志
SQL> select SEQUENCE#,FIRST_TIME,NEXT_TIME ,APPLIED from v$archived_log order by 1;

 SEQUENCE# FIRST_TIM NEXT_TIME APPLIED
---------- --------- --------- ---------
        10 31-DEC-17 31-DEC-17 YES
        11 31-DEC-17 31-DEC-17 YES
        12 31-DEC-17 31-DEC-17 YES
        13 31-DEC-17 31-DEC-17 YES
        
3. 验证数据库操作
 
在主库创建用户
SQL> create user test identified by test;

User created.
grant connect,resource to test;
在备库查看
SQL> select username from dba_users where username='TEST';
USERNAME
------------------------------
TEST
 

主备库切换操作验证


1. 主库执行切换
 
主库执行切换命令
SQL> alter database commit to switchover to physical standby with session shutdown;
Database altered.

重启主库角色变为备库
SQL> startup mount;
ORACLE instance started.
Total System Global Area  835104768 bytes
Fixed Size            2257840 bytes
Variable Size           679480400 bytes
Database Buffers    150994944 bytes
Redo Buffers          2371584 bytes
Database mounted.
SQL> select database_role from v$database;
DATABASE_ROLE
----------------
PHYSICAL STANDBY
 
2. 备库切换成主库
 
查看备库状态
SQL> select database_role from v$database;
DATABASE_ROLE
----------------
PHYSICAL STANDBY
SQL> select open_mode from v$database;
OPEN_MODE
--------------------
READ ONLY WITH APPLY

将备库切换成主库
SQL> alter database commit to switchover to primary with session shutdown;
Database altered.

查看备库角色
SQL> select database_role from v$database;
DATABASE_ROLE
----------------
PRIMARY

查看备库状态

SQL> select open_mode from v$database;
OPEN_MODE
--------------------
MOUNTED

Open备库(注：现在已经是主库)
SQL> alter database open;
Database altered.
 
将原主库切换成备库
SQL> alter database open;
Database altered.
SQL> alter database recover managed standby database using current logfile disconnect from session;
Database altered.

oracle 的主库闪回开启和设置
先关闭数据库 开启到mount状态
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup mount
ORACLE instance started.

Total System Global Area 4.0353E+10 bytes
Fixed Size                  2261928 bytes
Variable Size            4966059096 bytes
Database Buffers         3.5299E+10 bytes
Redo Buffers               85204992 bytes
Database mounted

开启闪回
SQL> alter database flashback on;
设置闪回的时间为两天
alter system set db_flashback_retention_target=172800;
开启数据库
SQL> alter database open;

Database altered.

查看一下闪回是否开启 和闪回的时间
SQL> select flashback_on from v$database;

FLASHBACK_ON
------------------
YES

SQL> show parameter db_flashback_retention_target;

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
db_flashback_retention_target        integer     172800


###备库灾难性切换

SYS@ptdbodb> SELECT THREAD#, LOW_SEQUENCE#, HIGH_SEQUENCE# FROM V$ARCHIVE_GAP;

no rows selected

SYS@ptdbodb> alter database recover managed standby database cancel;

Database altered.

SYS@ptdbodb>alter database recover managed standby database finish;

Database altered.

SYS@ptdbodb>alter database activate physical standby database;

Database altered.

SYS@ptdbodb>select open_mode from v$database;

OPEN_MODE
--------------------
MOUNTED

SYS@ptdbodb>alter database open;

Database altered.

SYS@ptdbodb> select open_mode from v$database;

OPEN_MODE
--------------------
READ WRITE

SYS@ptdbodb>select database_role from v$database;

DATABASE_ROLE
----------------
PRIMARY


####################查询管理命令######################################
select distinct thread#,max(sequence#) over(partition by thread#) a from v$archived_log; --运行在主备数据库之上检查归档文件是否完整
select dest_name,archived_thread#,archived_seq#,applied_thread#,applied_seq#,db_unique_name from v$archive_dest_status where  status='VALID'; —显示归档路径配置以及redo的应用情况
select process,client_process,sequence#,status from v$managed_standby;--显示物理standby进程当前状态
select sum(percent_space_used)*3/100 from v$flash_recovery_area_usage;  --可以查询闪回恢复区使用了多少GB

1. 数据库的闪回恢复区空间
 SELECT NAME,TRUNC(SPACE_LIMIT/1024/1024/1024, 3) LIMIT_GB,TRUNC(SPACE_USED/1024/1024/1024, 3) USED_GB,TRUNC(SPACE_USED / SPACE_LIMIT, 3) "USED%",TRUNC(SPACE_RECLAIMABLE, 3) RECLAIM,NUMBER_OF_FILES FROM V$RECOVERY_FILE_DEST V WHERE V.SPACE_LIMIT <> 0; 


select decode(count(*),1,'spfile','pfile') from v$spparameter where rownum=1 and isspecified = 'TRUE';--查看数据库使用pfile启动还是spfile启动
select thread#,max(sequence#) as "v$last_applied_log" from v$log_history group by thread#; —查询最后应用的归档文件
select dbms_metadata.get_ddl('TABLESPACE',ts.tablespace_name) from dba_tablespaces ts; --查询相应的表空间和数据文件
select *  from table(dbms_xplan.display_cursor(null,null,'ALLSTATS LAST'));  —查看oracle当前回话的SQL执行计划
select local.thread#,local.sequence# from (select thread#,sequence# from v$archived_log where dest_id=1) local where local.sequence# not in (select sequence# from v$archived_log where dest_id=2 and thread# = local.thread#); --查看物理standby 数据库未接收的日志文件
select process,status,thread#,sequence#,block#,blocks from v$managed_standby;--查看当前redo应用和redo传输的活动状态
select message from v$dataguard_status;   --查询DataGuard的事件
使用如下的查询语句可以得到各个数据文件的I/O分布：
select d.name name, f.phyrds, f.phyblkrd, f.phywrts, f.phyblkwrt, f.readtim, f.writetim from v$filestat f, v$datafile d where f.file# = d.file# order by f.phyrds desc, f.phywrts desc;

select thread#, max(sequence#), to_char(max(FIRST_TIME), 'yyyy-mm-dd hh24:mi:ss') from v$log_history where RESETLOGS_TIME = (select max(RESETLOGS_TIME) from v$log_history) group by thread#;

#查询排序普通用户下每张表的大小
select table_name,num_rows from user_tables order by num_rows desc;

############查询数据库的
查看建表语句
set line 200 pages 50000 wrap on long 999999 serveroutput on
EXECUTE DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,'STORAGE',false);
select dbms_metadata.get_ddl('TABLE','表名大写','用户名大写') from dual;
使用DBMS_STATS包手工收集统计数据，其实自动收集的gather_stats_job作业本质上也是使用包来实现收集的，区别看是否是oralce
####查看oracle普通用户QIPAI的所有权限
select privilege from dba_sys_privs where grantee='QIPAI' union select privilege from dba_sys_privs where grantee in (select granted_role from dba_role_privs where grantee='QIPAI' );
自动执行的内部行为。

dbms_stats包提供几种过程来统计不同粒度的数据，分为统计数据库，模式，表以及索引，如下：
gather_database_statistics   为全库表的表统计数据
gather_schema_statistics      为某个模式统计数据
gather_table_statistics      为某个特定的表收集统计数据
gather_index_statistics    为某个索引表统计数据
统计数据会存储在dba_tab_statistics 和 dba_tab_col_statistics数据字典中


##闪回查询
select * from DG_TRANSFER AS OF TIMESTAMP to_timestamp('20190826 12:23:01','yyyymmdd hh24:mi:ss');

例如：
为模式scott的所有表统计数据
exec dbms_stats.gather_schema_stats(ownname => 'SCOTT');
PL/SQL 过程已成功完成。

--查询scott用户分析表的情况
select last_analyzed,table_name,owner,num_rows,sample_size from dba_tables where owner='SCOTT';
LAST_ANALYZED  TABLE_NAME                     OWNER                            NUM_ROWS SAMPLE_SIZE
-------------- ------------------------------ ------------------------------ ---------- -----------
19-10月-13     DEPT                           SCOTT                                   4           4
19-10月-13     EMP                            SCOTT                                  14          14
19-10月-13     BONUS                          SCOTT                                   0           0
19-10月-13     SALGRADE                       SCOTT                                   5           5
19-10月-13     PAGE                           SCOTT                               71921       71921
--------------------- 
show parameter job_queue_processes;
--如果该参数为0，则统计信息包不会工作，
需要设置参数
alter system set job_queue_processes=20 ;

---查看自动统计信息的时间：
SELECT t1.window_name, t1.repeat_interval, t1.duration  FROM dba_scheduler_windows t1, dba_scheduler_wingroup_members t2  WHERE t1.window_name = t2.window_name  AND t2.window_group_name IN ('MAINTENANCE_WINDOW_GROUP', 'BSLN_MAINTAIN_STATS_SCHED');







3. 检查表空间的磁盘空间

select a.tablespace_name, round(a.total_size) "total_size(mb)",
round(a.total_size) - round(b.free_size,3) "unsed_size(mb)",
round(b.free_size,3) "free_size(mb)",
round(b.free_size/total_size *100,2) ||'%' free_rate
from
(select tablespace_name,sum(bytes) /1024/1024 total_size
from dba_data_files
group by tablespace_name) a,
(select tablespace_name,sum(bytes)/1024/1024 free_size
from dba_free_space
group by tablespace_name) b
where a.tablespace_name=b.tablespace_name(+);

##########################################
SELECT a.tablespace_name, 
round(a.bytes/(1024*1024*1024),2)||' GB' total, 
round(b.bytes/(1024*1024*1024),2)||' GB' used, 
round(c.bytes/(1024*1024*1024),2)||' GB' free, 
round((b.bytes * 100) / a.bytes)||'%' "% USED ", 
round((c.bytes * 100) / a.bytes)||'%' "% FREE " 
FROM sys.sm$ts_avail a, sys.sm$ts_used b, sys.sm$ts_free c 
WHERE a.tablespace_name = b.tablespace_name 
AND a.tablespace_name = c.tablespace_name;
#########################################
SELECT Upper(F.TABLESPACE_NAME)         "表空间名",
       D.TOT_GROOTTE_MB                 "表空间大小(M)",
       D.TOT_GROOTTE_MB - F.TOTAL_BYTES "已使用空间(M)",
       To_char(Round(( D.TOT_GROOTTE_MB - F.TOTAL_BYTES ) / D.TOT_GROOTTE_MB * 100, 2), '990.99')
       || '%'                           "使用比",
       F.TOTAL_BYTES                    "空闲空间(M)",
       F.MAX_BYTES                      "最大块(M)"
FROM   (SELECT TABLESPACE_NAME,
               Round(Sum(BYTES) / ( 1024 * 1024 ), 2) TOTAL_BYTES,
               Round(Max(BYTES) / ( 1024 * 1024 ), 2) MAX_BYTES
        FROM   SYS.DBA_FREE_SPACE
        GROUP  BY TABLESPACE_NAME) F,
       (SELECT DD.TABLESPACE_NAME,
               Round(Sum(DD.BYTES) / ( 1024 * 1024 ), 2) TOT_GROOTTE_MB
        FROM   SYS.DBA_DATA_FILES DD
        GROUP  BY DD.TABLESPACE_NAME) D
WHERE  D.TABLESPACE_NAME = F.TABLESPACE_NAME
ORDER  BY 1;


############################################

 SELECT UPPER(F.TABLESPACE_NAME) AS "表空间名称", 
         ROUND(D.AVAILB_BYTES ,2) AS "表空间大小(G)", 
         ROUND(D.MAX_BYTES,2) AS "最终表空间大小(G)", 
         ROUND((D.AVAILB_BYTES - F.USED_BYTES),2) AS "已使用空间(G)", 
         TO_CHAR(ROUND((D.AVAILB_BYTES - F.USED_BYTES) / D.AVAILB_BYTES * 100, 
             2), '999.99') AS "使用比", 
         ROUND(F.USED_BYTES, 6) AS "空闲空间(G)", 
         F.MAX_BYTES AS "最大块(M)" 
  FROM (
         SELECT TABLESPACE_NAME, 
                 ROUND(SUM(BYTES) / (1024 * 1024 * 1024), 6) USED_BYTES, 
                 ROUND(MAX(BYTES) / (1024 * 1024 * 1024), 6) MAX_BYTES 
         FROM SYS.DBA_FREE_SPACE 
         GROUP BY TABLESPACE_NAME) F, 
       (SELECT DD.TABLESPACE_NAME, 
                 ROUND(SUM(DD.BYTES) / (1024 * 1024 * 1024), 6) AVAILB_BYTES, 
             ROUND(SUM(DECODE(DD.MAXBYTES, 0, DD.BYTES, DD.MAXBYTES))/(1024*1024*1024),6) MAX_BYTES 
        FROM SYS.DBA_DATA_FILES DD 
        GROUP BY DD.TABLESPACE_NAME) D 
         WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME 
ORDER BY 4 DESC;


###################查询用户所有的分区表按月分区的类型表
select table_name,interval from user_part_tables where interval like '%MONTH%' ;


###################
oracle中根据时间获取最新的一条数据

select  *  from DG_TRANSFER   where rownum=1 order by CREATETIME;


添加日志
 alter database add logfile thread 1 group 21  ('/home/u01/app/oracle/racdbpdg/oradata/redo21.log') size 50m;
###查看日志
SELECT GROUP#,TYPE,MEMBER FROM V$LOGFILE;
SELECT GROUP#,THREAD#,SEQUENCE#,ARCHIVED,STATUS FROM V$STANDBY_LOG;


查看保护级别，当前角色
set linesize 1000
select database_role,db_unique_name,open_mode,protection_mode,protection_level,switchover_status from v$database; 

  


修改保护模式
改为最大保护模式（mount下，而且日志为lgwr async affirm）
alter database set standby database to maximize protection;

修改为最高可用模式
alter database set standby database to maximize availability;

修改为最大性能模式

ALTER DATABASE SET STANDBY DATABASE TO MAXIMIZE PERFORMANCE;

################归档清理脚本####################
#!/bin/bash
export ORACLE_SID=dnacp
 rman target /  log=/home/oracle/sh/log/dnacp_archive_del.log append  <<EOF
run { 
CROSSCHECK archivelog all;
DELETE NOPROMPT force ARCHIVELOG ALL COMPLETED BEFORE 'SYSDATE-7';
}

EOF

                1.修改表空间名称：
alter tablespace  tablespace_name1 rename to tablespace_name2;
 
2.修改数据文件名称：
1）先将联机状态的需要修改的表空间设置为脱机状态：
ALTER TABLESPACE tablespace_name OFFLINE;
2）然后将数据物理文件修改名称
3）再通过sqlplus或者pl/sql修改数据文件名称：
alter tablespace tablespace_name rename DATAFILE 'E:\APP\HUIJUAN\PRODUCT\LOCALDATEBASE\datafile_name1' TO 'E:\APP\HUIJUAN\PRODUCT\LOCALDATEBASE\datafile_name2';
     
分区表的管理     
 ###查看某张表的分区信息
  select TABLE_NAME,NUM_ROWS,BLOCKS,LAST_ANALYZED from dba_tables where TABLE_NAME='DG_WALLET_TRANSFER';
 ##查询当前用户下面的表是否有分区表
 SELECT TABLE_NAME,PARTITIONED FROM ALL_TABLES WHERE TABLESPACE_NAME IS NULL ;
 ##查询数据库所有分区表的信息
 select * from user_tables a where a.partitioned='YES';
 #oracle 查看某张表的分区
  select partition_name from user_tab_partitions where table_name='表'
  ###查看表的建表语句
  select dbms_metadata.get_ddl('TABLE','TABLE_NAME') from dual;
-查看当前用户下分区表及对应索引的相关信息
--（表及索引多大，多少个分区，在哪一个列建了分区，表及索引的分区的类型是什么，有无子分区）
set linesize 366
col partitioning_type format a10 
col subpartitioning_type format a10 
col partition_count format 99999 
col column_name format a20
col object_type format a10
col blevel format 9
col num_rows format 99999999
col leaf_blocks format 999999
col column_position format 9
col partition_name format a28
col segment_type format a20
col index_name format a28
col table_name format a30
col last_analyzed format date
col status format a8

---01 该表是否是分区表，分区表的分区类型是什么，是否有子分区，分区总数有多少
select partitioning_type, 
       subpartitioning_type, 
       partition_count
  from user_part_tables
 where table_name ='RANGE_PART_TAB';

--02 该分区表在哪一列上建分区,有无多列联合建分区
select column_name, 
       object_type, 
       column_position
  from user_part_key_columns
 where name ='RANGE_PART_TAB';


 
--03 该分区表有多大？
select sum(bytes) / 1024 / 1024
  from user_segments
 where segment_name ='RANGE_PART_TAB';

--04 该分区表各分区分别有多大，各个分区名是什么。
select partition_name, 
       segment_type, 
       bytes
  from user_segments
 where segment_name ='RANGE_PART_TAB';


--05 该分区表的统计信息收集情况
select table_name,
       partition_name,
       last_analyzed,
       partition_position,      
       num_rows
  from user_tab_statistics t
 where table_name ='RANGE_PART_TAB';


--06 查该分区表有无索引，分别什么类型,全局索引是否失效，此外还可看统计信息收集情况。
--(其中status值为N/A 表示分区索引，分区索引是否失效是在user_ind_partitions中查看)
select table_name, 
       index_name, 
       last_analyzed,
       blevel,
       num_rows,
       leaf_blocks,
       distinct_keys,
       status
  from user_indexes
 where table_name ='RANGE_PART_TAB';


--07 该分区表在哪些列上建了索引
select index_name, 
       column_name, 
       column_position
  from user_ind_columns
 where table_name = 'RANGE_PART_TAB';



--08 该分区表上的各索引分别有多大。   
select segment_name,segment_type,sum(bytes)/1024/1024
  from user_segments
 where segment_name in
       (select index_name
          from user_indexes
         where table_name ='RANGE_PART_TAB')
group by segment_name,segment_type ;  

--09 该分区表的索引段的分配情况
select segment_name
       partition_name, 
       segment_type, 
       bytes
  from user_segments
 where segment_name in
       (select index_name
          from user_indexes
         where table_name ='RANGE_PART_TAB');

         
         
--10 分区索引相关信息及统计信息、是否失效查看。
select t2.table_name,
       t1.index_name,
       t1.partition_name,
       t1.last_analyzed,
       t1.blevel,
       t1.num_rows,
       t1.leaf_blocks,
       t1.status       
  from user_ind_partitions t1, user_indexes t2
where t1.index_name = t2.index_name
   and t2.table_name='RANGE_PART_TAB';    

ORA-14400: 插入的分区关键字未映射到任何分区
　　最近总有同事反应这个问题，问题很简单，就是字面意思，说的是插入的数据没有相对应的分区来存储，但是奇怪的是这些表建立时都是以间隔分区(INTERVAL)分区的方式建立的，按理说新的数据进来时会自动创建新的分区来存储数据，不应该再有14400错误。
　　看了下建表语句，发现建立分区时partition by range(col_name)下面并没有INTERVAL关键字，问题出现了，建表的时候明明指定了INTERVAL分区，为什么在plsql中查看建表语句INTERVAL消失了呢，做了下测试，新建了一个range分区表，插入数据后会提示14400错误，但是对interval插入数据就不会提示错误，所以我的猜想是虽然建表语句中并未出现interval关键字，但是interval分区还是不变的，具体为什么不显示，有待考证。
　　文章开头说的问题的答案就很明显了，是同事在创建分区表的时候直接复制的建表语句，并为新增interval关键字，所以他本意想建的是interval分区，但是建成了range分区，解决方法也很简单，一个alter就ok了，会将原有的range转换为interval
　　ALTER TABLE table_name SET INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'));



ORACLE从共享池删除指定SQL的执行计划
alter system flush shared_pool;
select address, hash_value, sql_text  from v$sqlarea where sql_id='5kdqcy9tcv9mb';

exec dbms_shared_pool.purge('00000007F56C9B48,1926080107','C');


5.启动INMEMORY

启用exdata特性
alter system set "_exadata_feature_on"=true scope=spfile;

SHOW PARAMETER inmemory;
需要重启数据库
ALTER SYSTEM SET INMEMORY_SIZE=350G SCOPE=SPFILE;





